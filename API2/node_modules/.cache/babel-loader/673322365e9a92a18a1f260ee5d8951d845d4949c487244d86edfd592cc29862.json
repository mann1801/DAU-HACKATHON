{"ast":null,"code":"/**\n * Geolocation Service for Cyclone Monitoring System\n * Provides location-based functionality for finding nearest monitoring stations\n */\n\nclass GeolocationService {\n  constructor() {\n    this.userLocation = null;\n    this.watchId = null;\n    this.isWatching = false;\n  }\n\n  /**\n   * Get user's current position\n   * @returns {Promise<{lat: number, lon: number}>}\n   */\n  async getCurrentPosition() {\n    return new Promise((resolve, reject) => {\n      if (!navigator.geolocation) {\n        reject(new Error('Geolocation is not supported by this browser'));\n        return;\n      }\n      const options = {\n        enableHighAccuracy: true,\n        timeout: 10000,\n        maximumAge: 300000 // 5 minutes\n      };\n      navigator.geolocation.getCurrentPosition(position => {\n        const location = {\n          lat: position.coords.latitude,\n          lon: position.coords.longitude,\n          accuracy: position.coords.accuracy,\n          timestamp: position.timestamp\n        };\n        this.userLocation = location;\n        resolve(location);\n      }, error => {\n        let errorMessage = 'Unable to retrieve location';\n        switch (error.code) {\n          case error.PERMISSION_DENIED:\n            errorMessage = 'Location access denied by user';\n            break;\n          case error.POSITION_UNAVAILABLE:\n            errorMessage = 'Location information unavailable';\n            break;\n          case error.TIMEOUT:\n            errorMessage = 'Location request timed out';\n            break;\n        }\n        reject(new Error(errorMessage));\n      }, options);\n    });\n  }\n\n  /**\n   * Start watching user's position for continuous updates\n   * @param {Function} callback - Called when position changes\n   */\n  startWatching(callback) {\n    if (!navigator.geolocation || this.isWatching) {\n      return;\n    }\n    const options = {\n      enableHighAccuracy: true,\n      timeout: 15000,\n      maximumAge: 60000 // 1 minute\n    };\n    this.watchId = navigator.geolocation.watchPosition(position => {\n      const location = {\n        lat: position.coords.latitude,\n        lon: position.coords.longitude,\n        accuracy: position.coords.accuracy,\n        timestamp: position.timestamp\n      };\n      this.userLocation = location;\n      callback(location);\n    }, error => {\n      console.warn('Geolocation watch error:', error.message);\n    }, options);\n    this.isWatching = true;\n  }\n\n  /**\n   * Stop watching user's position\n   */\n  stopWatching() {\n    if (this.watchId !== null) {\n      navigator.geolocation.clearWatch(this.watchId);\n      this.watchId = null;\n      this.isWatching = false;\n    }\n  }\n\n  /**\n   * Calculate distance between two points using Haversine formula\n   * @param {number} lat1 - Latitude of first point\n   * @param {number} lon1 - Longitude of first point\n   * @param {number} lat2 - Latitude of second point\n   * @param {number} lon2 - Longitude of second point\n   * @returns {number} Distance in kilometers\n   */\n  calculateDistance(lat1, lon1, lat2, lon2) {\n    const R = 6371; // Earth's radius in kilometers\n    const dLat = this.toRadians(lat2 - lat1);\n    const dLon = this.toRadians(lon2 - lon1);\n    const a = Math.sin(dLat / 2) * Math.sin(dLat / 2) + Math.cos(this.toRadians(lat1)) * Math.cos(this.toRadians(lat2)) * Math.sin(dLon / 2) * Math.sin(dLon / 2);\n    const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));\n    return R * c;\n  }\n\n  /**\n   * Convert degrees to radians\n   * @param {number} degrees \n   * @returns {number} Radians\n   */\n  toRadians(degrees) {\n    return degrees * (Math.PI / 180);\n  }\n\n  /**\n   * Find nearest monitoring stations to user's location\n   * @param {Object} stations - Dictionary of stations\n   * @param {number} limit - Maximum number of stations to return\n   * @returns {Array} Sorted array of nearest stations with distances\n   */\n  findNearestStations(stations, limit = 5) {\n    if (!this.userLocation || !stations) {\n      return [];\n    }\n    const stationsWithDistance = Object.entries(stations).map(([id, station]) => {\n      const distance = this.calculateDistance(this.userLocation.lat, this.userLocation.lon, station.lat, station.lon);\n      return {\n        id,\n        ...station,\n        distance: Math.round(distance * 10) / 10 // Round to 1 decimal place\n      };\n    });\n\n    // Sort by distance and return top results\n    return stationsWithDistance.sort((a, b) => a.distance - b.distance).slice(0, limit);\n  }\n\n  /**\n   * Get user's approximate location info (city, country) using reverse geocoding\n   * @returns {Promise<Object>} Location information\n   */\n  async getReverseGeocode() {\n    if (!this.userLocation) {\n      throw new Error('User location not available');\n    }\n    try {\n      // Using a free reverse geocoding service\n      const response = await fetch(`https://api.bigdatacloud.net/data/reverse-geocode-client?latitude=${this.userLocation.lat}&longitude=${this.userLocation.lon}&localityLanguage=en`);\n      if (!response.ok) {\n        throw new Error('Reverse geocoding failed');\n      }\n      const data = await response.json();\n      return {\n        city: data.city || data.locality || 'Unknown',\n        country: data.countryName || 'Unknown',\n        region: data.principalSubdivision || '',\n        countryCode: data.countryCode || ''\n      };\n    } catch (error) {\n      console.warn('Reverse geocoding error:', error);\n      return {\n        city: 'Unknown',\n        country: 'Unknown',\n        region: '',\n        countryCode: ''\n      };\n    }\n  }\n\n  /**\n   * Check if geolocation is supported and available\n   * @returns {boolean}\n   */\n  isSupported() {\n    return 'geolocation' in navigator;\n  }\n\n  /**\n   * Get cached user location\n   * @returns {Object|null}\n   */\n  getCachedLocation() {\n    return this.userLocation;\n  }\n\n  /**\n   * Clear cached location data\n   */\n  clearLocation() {\n    this.userLocation = null;\n    this.stopWatching();\n  }\n}\n\n// Create singleton instance\nconst geolocationService = new GeolocationService();\nexport default geolocationService;","map":{"version":3,"names":["GeolocationService","constructor","userLocation","watchId","isWatching","getCurrentPosition","Promise","resolve","reject","navigator","geolocation","Error","options","enableHighAccuracy","timeout","maximumAge","position","location","lat","coords","latitude","lon","longitude","accuracy","timestamp","error","errorMessage","code","PERMISSION_DENIED","POSITION_UNAVAILABLE","TIMEOUT","startWatching","callback","watchPosition","console","warn","message","stopWatching","clearWatch","calculateDistance","lat1","lon1","lat2","lon2","R","dLat","toRadians","dLon","a","Math","sin","cos","c","atan2","sqrt","degrees","PI","findNearestStations","stations","limit","stationsWithDistance","Object","entries","map","id","station","distance","round","sort","b","slice","getReverseGeocode","response","fetch","ok","data","json","city","locality","country","countryName","region","principalSubdivision","countryCode","isSupported","getCachedLocation","clearLocation","geolocationService"],"sources":["C:/Users/Kisha/Desktop/HACKATHON/DAU-HACKATHON/API2/src/services/geolocationService.js"],"sourcesContent":["/**\n * Geolocation Service for Cyclone Monitoring System\n * Provides location-based functionality for finding nearest monitoring stations\n */\n\nclass GeolocationService {\n  constructor() {\n    this.userLocation = null;\n    this.watchId = null;\n    this.isWatching = false;\n  }\n\n  /**\n   * Get user's current position\n   * @returns {Promise<{lat: number, lon: number}>}\n   */\n  async getCurrentPosition() {\n    return new Promise((resolve, reject) => {\n      if (!navigator.geolocation) {\n        reject(new Error('Geolocation is not supported by this browser'));\n        return;\n      }\n\n      const options = {\n        enableHighAccuracy: true,\n        timeout: 10000,\n        maximumAge: 300000 // 5 minutes\n      };\n\n      navigator.geolocation.getCurrentPosition(\n        (position) => {\n          const location = {\n            lat: position.coords.latitude,\n            lon: position.coords.longitude,\n            accuracy: position.coords.accuracy,\n            timestamp: position.timestamp\n          };\n          this.userLocation = location;\n          resolve(location);\n        },\n        (error) => {\n          let errorMessage = 'Unable to retrieve location';\n          switch (error.code) {\n            case error.PERMISSION_DENIED:\n              errorMessage = 'Location access denied by user';\n              break;\n            case error.POSITION_UNAVAILABLE:\n              errorMessage = 'Location information unavailable';\n              break;\n            case error.TIMEOUT:\n              errorMessage = 'Location request timed out';\n              break;\n          }\n          reject(new Error(errorMessage));\n        },\n        options\n      );\n    });\n  }\n\n  /**\n   * Start watching user's position for continuous updates\n   * @param {Function} callback - Called when position changes\n   */\n  startWatching(callback) {\n    if (!navigator.geolocation || this.isWatching) {\n      return;\n    }\n\n    const options = {\n      enableHighAccuracy: true,\n      timeout: 15000,\n      maximumAge: 60000 // 1 minute\n    };\n\n    this.watchId = navigator.geolocation.watchPosition(\n      (position) => {\n        const location = {\n          lat: position.coords.latitude,\n          lon: position.coords.longitude,\n          accuracy: position.coords.accuracy,\n          timestamp: position.timestamp\n        };\n        this.userLocation = location;\n        callback(location);\n      },\n      (error) => {\n        console.warn('Geolocation watch error:', error.message);\n      },\n      options\n    );\n\n    this.isWatching = true;\n  }\n\n  /**\n   * Stop watching user's position\n   */\n  stopWatching() {\n    if (this.watchId !== null) {\n      navigator.geolocation.clearWatch(this.watchId);\n      this.watchId = null;\n      this.isWatching = false;\n    }\n  }\n\n  /**\n   * Calculate distance between two points using Haversine formula\n   * @param {number} lat1 - Latitude of first point\n   * @param {number} lon1 - Longitude of first point\n   * @param {number} lat2 - Latitude of second point\n   * @param {number} lon2 - Longitude of second point\n   * @returns {number} Distance in kilometers\n   */\n  calculateDistance(lat1, lon1, lat2, lon2) {\n    const R = 6371; // Earth's radius in kilometers\n    const dLat = this.toRadians(lat2 - lat1);\n    const dLon = this.toRadians(lon2 - lon1);\n    \n    const a = \n      Math.sin(dLat / 2) * Math.sin(dLat / 2) +\n      Math.cos(this.toRadians(lat1)) * Math.cos(this.toRadians(lat2)) *\n      Math.sin(dLon / 2) * Math.sin(dLon / 2);\n    \n    const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));\n    return R * c;\n  }\n\n  /**\n   * Convert degrees to radians\n   * @param {number} degrees \n   * @returns {number} Radians\n   */\n  toRadians(degrees) {\n    return degrees * (Math.PI / 180);\n  }\n\n  /**\n   * Find nearest monitoring stations to user's location\n   * @param {Object} stations - Dictionary of stations\n   * @param {number} limit - Maximum number of stations to return\n   * @returns {Array} Sorted array of nearest stations with distances\n   */\n  findNearestStations(stations, limit = 5) {\n    if (!this.userLocation || !stations) {\n      return [];\n    }\n\n    const stationsWithDistance = Object.entries(stations).map(([id, station]) => {\n      const distance = this.calculateDistance(\n        this.userLocation.lat,\n        this.userLocation.lon,\n        station.lat,\n        station.lon\n      );\n\n      return {\n        id,\n        ...station,\n        distance: Math.round(distance * 10) / 10 // Round to 1 decimal place\n      };\n    });\n\n    // Sort by distance and return top results\n    return stationsWithDistance\n      .sort((a, b) => a.distance - b.distance)\n      .slice(0, limit);\n  }\n\n  /**\n   * Get user's approximate location info (city, country) using reverse geocoding\n   * @returns {Promise<Object>} Location information\n   */\n  async getReverseGeocode() {\n    if (!this.userLocation) {\n      throw new Error('User location not available');\n    }\n\n    try {\n      // Using a free reverse geocoding service\n      const response = await fetch(\n        `https://api.bigdatacloud.net/data/reverse-geocode-client?latitude=${this.userLocation.lat}&longitude=${this.userLocation.lon}&localityLanguage=en`\n      );\n      \n      if (!response.ok) {\n        throw new Error('Reverse geocoding failed');\n      }\n\n      const data = await response.json();\n      return {\n        city: data.city || data.locality || 'Unknown',\n        country: data.countryName || 'Unknown',\n        region: data.principalSubdivision || '',\n        countryCode: data.countryCode || ''\n      };\n    } catch (error) {\n      console.warn('Reverse geocoding error:', error);\n      return {\n        city: 'Unknown',\n        country: 'Unknown',\n        region: '',\n        countryCode: ''\n      };\n    }\n  }\n\n  /**\n   * Check if geolocation is supported and available\n   * @returns {boolean}\n   */\n  isSupported() {\n    return 'geolocation' in navigator;\n  }\n\n  /**\n   * Get cached user location\n   * @returns {Object|null}\n   */\n  getCachedLocation() {\n    return this.userLocation;\n  }\n\n  /**\n   * Clear cached location data\n   */\n  clearLocation() {\n    this.userLocation = null;\n    this.stopWatching();\n  }\n}\n\n// Create singleton instance\nconst geolocationService = new GeolocationService();\n\nexport default geolocationService;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}